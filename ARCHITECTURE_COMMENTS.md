# Подробные комментарии к диаграммам архитектуры

## 1. Общая архитектура системы

### Описание
Эта диаграмма показывает **общую структуру системы** и взаимодействие всех компонентов на высоком уровне.

### Компоненты по слоям:

#### Client Layer (Слой клиентов)
- **Reviewer Browser** (синий) - браузер проверяющего
  - Открывает `/reviewer` для управления сессиями
  - Имеет полный доступ ко всем функциям
  
- **Candidate Browser** (оранжевый) - браузер кандидата
  - Открывает `/candidate/{token}` по уникальному токену
  - Ограниченный доступ (только просмотр и комментарии)

**Важно:** Разные браузеры/окна для разных ролей - это ключевая особенность разделения ролей.

#### Frontend Layer (Слой фронтенда)
- **React Router** - маршрутизация
  - Определяет, какой компонент показать на основе URL
  - `/reviewer` → ReviewerDashboard
  - `/candidate/:token` → CandidateView
  
- **ReviewerDashboard** - дашборд проверяющего
  - Список всех сессий
  - Создание новых сессий
  - Просмотр деталей сессии
  - Управление (оценка, продление, отчёты)
  
- **CandidateView** - интерфейс кандидата
  - Просмотр diff кода
  - Добавление комментариев
  - Таймер сессии (без возможности продления)

**Архитектурное решение:** Разделение UI на разные компоненты обеспечивает чёткое разделение ролей на уровне интерфейса.

#### Backend Layer (Слой бэкенда)
- **FastAPI API** (зелёный) - основной API сервер
  - Обрабатывает все HTTP запросы
  - Валидация данных через Pydantic
  - Маршрутизация запросов к соответствующим обработчикам
  
- **Gitea Client** - клиент для работы с Gitea
  - Обёртка над Gitea REST API
  - Создание пользователей, репозиториев, PR
  - Изоляция логики работы с Gitea от основного API

**Паттерн:** Gitea Client использует паттерн **Adapter** - адаптирует Gitea API под нужды нашего приложения.

#### Data Layer (Слой данных)
- **SQLite** (фиолетовый) - основная база данных
  - Хранит все сессии, комментарии, метаданные
  - Файл: `api/reviews.db`
  - Легковесная БД, подходит для MVP
  
- **Redis** (красный) - очередь задач
  - Хранит задачи для асинхронной обработки
  - Используется RQ (Redis Queue) для управления очередью
  - Обеспечивает неблокирующую обработку длительных операций

**Почему Redis?** Оценка кода может занимать время, поэтому выносим её в фоновый процесс через очередь.

#### Processing Layer (Слой обработки)
- **RQ Worker** (жёлтый) - фоновый обработчик
  - Слушает очередь Redis
  - Выполняет задачу `evaluate(session_id)`
  - Генерирует отчёты (TP, FP, FN, Score, Grade)
  - Сохраняет результаты в файлы

**Асинхронность:** Worker работает независимо от API, что позволяет API быстро отвечать на запросы.

#### External Services (Внешние сервисы)
- **Gitea** (бирюзовый) - Git сервер
  - Хранит репозитории для каждой сессии
  - Управляет пользователями кандидатов
  - Предоставляет Git workflow (PR, комментарии, ветки)

**Интеграция:** Gitea опционален - если токен не установлен, система работает без него (fallback на старый workflow).

#### Storage (Хранилище)
- **Artifacts** - генерируемые файлы
  - `{session_id}_diff.patch` - diff кода
  - `{session_id}_report.txt` - текстовый отчёт
  - `{session_id}_report.pdf` - PDF отчёт
  
- **Gitea Data** - данные Gitea
  - Репозитории кандидатов
  - История коммитов
  - Pull Requests

### Потоки данных:

1. **Reviewer → API → DB**: Создание сессии, просмотр данных
2. **Candidate → API → DB**: Получение сессии по токену, добавление комментариев
3. **API → Redis → Worker**: Асинхронная обработка оценки
4. **API → GiteaClient → Gitea**: Интеграция с Git сервером

---

## 2. Поток создания сессии

### Описание
Эта **sequence диаграмма** показывает пошаговый процесс создания новой сессии проверяющим.

### Шаги:

#### 1. Инициация (Reviewer → API)
```
POST /api/reviewer/sessions
{
  "candidate_name": "Иван Иванов",
  "mr_package": "demo_package",
  "reviewer_name": "Reviewer"
}
```

#### 2. Сохранение в БД (API → DB)
- Создаётся запись в таблице `sessions`
- Генерируются токены (`access_token`, `reviewer_token`)
- Устанавливается время истечения (2 часа)
- Возвращается `session_id`

**Важно:** Сначала создаём запись в БД, чтобы получить `session_id`, который используется для именования репозитория.

#### 3. Условная интеграция с Gitea (alt Gitea enabled)

**3.1. Создание пользователя**
- `create_user(candidate_XXX)` - создаёт пользователя в Gitea
- Имя пользователя: `candidate_ivan_ivanov` (безопасное имя из candidate_name)
- Email: `candidate_ivan_ivanov@code-review.local`
- Пароль генерируется автоматически

**3.2. Создание репозитория**
- `create_repository(session_YYY)` - создаёт приватный репозиторий
- Имя репозитория: `session_{session_id}`
- Описание: "Code review session for {candidate_name}"
- Приватный: `true`

**3.3. Инициализация стартового кода**
- `create_file(main.py)` - создаёт начальный файл в репозитории
- Содержимое: базовый код для code review
- Коммит: "Initial code for code review"

**3.4. Обновление БД**
- `UPDATE gitea_enabled=1` - помечаем, что Gitea интеграция активна
- Сохраняем `gitea_user` и `gitea_repo` в БД

**Обработка ошибок:** Если Gitea недоступен или токен не установлен, сессия создаётся без Gitea (fallback).

#### 4. Ответ (API → Reviewer)
```json
{
  "session_id": 1,
  "access_token": "abc123xyz789...",
  "reviewer_token": "reviewer_xyz...",
  "candidate_url": "/candidate/abc123xyz789...",
  "reviewer_url": "/reviewer/sessions/1",
  "gitea": {
    "enabled": true,
    "user": "candidate_ivan_ivanov",
    "repo": "session_1",
    "clone_url": "http://gitea:3000/candidate_ivan_ivanov/session_1.git",
    "web_url": "http://localhost:3000/candidate_ivan_ivanov/session_1"
  }
}
```

**Использование:** Reviewer копирует `access_token` и отправляет ссылку кандидату.

---

## 3. Поток работы кандидата

### Описание
Эта диаграмма показывает, как кандидат взаимодействует с системой через свой интерфейс.

### Шаги:

#### 1. Получение сессии по токену
```
GET /api/candidate/sessions/{token}
```

**Безопасность:** Доступ только по токену. Если токен неверный - 404.

**Процесс:**
- API ищет сессию в БД по `access_token`
- Проверяет, не истекла ли сессия
- Возвращает данные сессии (без чувствительной информации)

**Ответ:**
```json
{
  "session_id": 1,
  "candidate_name": "Иван Иванов",
  "expires_at": "2024-11-15T23:00:00Z",
  "status": "active"
}
```

#### 2. Получение diff кода
```
GET /api/candidate/sessions/{token}/diff
```

**Процесс:**
- API находит `session_id` по токену
- Читает файл `/artifacts/{session_id}_diff.patch`
- Возвращает diff в текстовом формате

**Формат:** Стандартный Git diff format
```
diff --git a/main.py b/main.py
index abc123..def456 100644
--- a/main.py
+++ b/main.py
@@ -1,5 +1,6 @@
 def greet():
-    print("Hi")
+    print("Hello, secure world!")
+    # TODO: add input validation
     return True
```

**Отображение:** Monaco Editor показывает diff с подсветкой синтаксиса.

#### 3. Добавление комментария
```
POST /api/candidate/sessions/{token}/comments
{
  "file": "main.py",
  "line_range": "15-15",
  "type": "bug",
  "severity": "medium",
  "text": "Потенциальная утечка памяти"
}
```

**Процесс:**
- API находит сессию по токену
- Загружает существующие комментарии из БД (JSON)
- Добавляет новый комментарий
- Сохраняет обновлённый список в БД

**Хранение:** Комментарии хранятся как JSON массив в поле `comments` таблицы `sessions`.

**Валидация:**
- Проверка, что сессия не истекла
- Проверка обязательных полей
- Проверка формата `line_range`

---

## 4. Поток оценки сессии

### Описание
Эта диаграмма показывает асинхронный процесс оценки работы кандидата.

### Шаги:

#### 1. Запуск оценки (Reviewer → API → Redis)
```
POST /api/reviewer/sessions/{id}/evaluate
```

**Процесс:**
- API добавляет задачу в очередь Redis
- Используется RQ (Redis Queue)
- Задача: `evaluate(session_id)`
- Возвращается `job_id` для отслеживания

**Почему асинхронно?** Оценка может занимать время (сравнение комментариев, вычисление метрик), поэтому выполняется в фоне.

#### 2. Обработка задачи (Worker)
```
Worker → Redis: dequeue job
```

**Worker получает задачу:**
- Извлекает `session_id` из задачи
- Загружает данные из БД

#### 3. Загрузка данных (Worker → DB, Artifacts)
```
SELECT comments, mr_package FROM sessions WHERE id = ?
```

**Данные:**
- `comments` - JSON массив комментариев кандидата
- `mr_package` - имя пакета для поиска golden truth

**Golden Truth:**
- Читает `/mr_packages/{mr_package}/golden_truth.json`
- Содержит эталонные комментарии для сравнения

#### 4. Обработка (Worker внутренние операции)

**4.1. Сравнение комментариев**
- Сопоставляет комментарии кандидата с golden truth
- Учитывает `file`, `line_range`, `type`, `severity`

**4.2. Вычисление метрик**
- **TP (True Positives)** - правильно найденные проблемы
- **FP (False Positives)** - ложные срабатывания
- **FN (False Negatives)** - пропущенные проблемы

**4.3. Вычисление Score и Grade**
- **Score** = TP / (TP + FP + FN)
- **Grade** = A/B/C/D на основе Score

#### 5. Сохранение отчёта (Worker → Artifacts)
```
write /artifacts/{session_id}_report.txt
```

**Формат отчёта:**
```
Evaluation Report for Session #1
==================================================

True Positives (TP): 5
False Positives (FP): 2
False Negatives (FN): 1
Total: 8

Score: 0.625
Grade: C
```

#### 6. Получение отчёта (Reviewer → API → Artifacts)
```
GET /api/reviewer/sessions/{id}/report
```

**Процесс:**
- API читает файл отчёта
- Если файл не существует - возвращает "Отчёт ещё не готов..."
- Возвращает текстовый отчёт

**PDF версия:**
- `GET /api/reviewer/sessions/{id}/report/pdf`
- Генерирует PDF через WeasyPrint
- Включает diff, комментарии, метрики

---

## 5. Разделение ролей

### Описание
Эта диаграмма визуализирует права доступа для каждой роли.

### Reviewer Access (Права проверяющего)

**Последовательность действий:**
1. **Create Sessions** - создание новых сессий
2. **View Sessions List** - просмотр всех сессий
3. **View Session Details** - детали конкретной сессии
4. **Evaluate Session** - запуск оценки
5. **View Reports** - просмотр отчётов (текст + PDF)
6. **Extend Session** - продление сессии на 30 минут
7. **Access Gitea** - доступ к репозиториям в Gitea

**Особенности:**
- Полный контроль над сессиями
- Доступ ко всем данным
- Может управлять жизненным циклом сессии

### Candidate Access (Права кандидата)

**Последовательность действий:**
1. **View Session by Token** - доступ по токену
2. **View Diff** - просмотр diff кода
3. **Add Comments** - добавление комментариев
4. **View Timer** - просмотр оставшегося времени

**Ограничения:**
- Нет доступа к отчётам (❌ View Reports)
- Не может продлевать сессию (❌ Extend Session)
- Не может создавать сессии (❌ Create Sessions)

**Безопасность:**
- Доступ только по токену
- Токен уникален для каждой сессии
- Токен нельзя угадать (32 байта, URL-safe)

### Restricted (Запрещённые действия)

Пунктирные линии показывают, что кандидат **не имеет доступа** к этим функциям, даже если попытается обратиться напрямую к API.

**Защита на уровне API:**
- Endpoints для отчётов доступны только через `/api/reviewer/*`
- Endpoint продления доступен только через `/api/reviewer/*`
- Кандидат использует `/api/candidate/*` endpoints, которые не имеют этих функций

---

## 6. Структура данных

### Описание
ER-диаграмма показывает структуру базы данных.

### Таблица SESSIONS

**Первичный ключ:**
- `id` (INTEGER) - уникальный идентификатор сессии

**Основные поля:**
- `candidate_id` - старый формат ID (для обратной совместимости)
- `candidate_name` - имя кандидата (человекочитаемое)
- `reviewer_name` - имя проверяющего
- `mr_package` - имя пакета MR для оценки

**Комментарии:**
- `comments` (JSON) - массив комментариев в формате JSON
  ```json
  [
    {
      "file": "main.py",
      "line_range": "15-15",
      "type": "bug",
      "severity": "medium",
      "text": "Потенциальная утечка памяти"
    }
  ]
  ```

**Временные метки:**
- `created_at` - время создания (ISO 8601 с 'Z' для UTC)
- `expires_at` - время истечения (ISO 8601 с 'Z' для UTC)

**Токены:**
- `access_token` (UNIQUE) - токен для кандидата
- `reviewer_token` - токен для проверяющего (опционально)

**Статус:**
- `status` - статус сессии ('active', 'completed', 'expired')

**Gitea интеграция:**
- `gitea_user` - имя пользователя в Gitea
- `gitea_repo` - имя репозитория в Gitea
- `gitea_pr_id` - ID Pull Request (если создан)
- `gitea_enabled` (BOOLEAN) - флаг активности Gitea интеграции

### Таблица COMMENTS (логическая)

**Важно:** Комментарии не хранятся в отдельной таблице, а как JSON в поле `comments` таблицы `sessions`.

**Структура комментария:**
- `file` - имя файла
- `line_range` - диапазон строк (например, "15-15" или "10-20")
- `type` - тип комментария ('bug', 'security', 'style', 'performance')
- `severity` - серьёзность ('critical', 'high', 'medium', 'low')
- `text` - текст комментария

**Связь:**
- `SESSIONS ||--o{ COMMENTS : contains`
- Один к многим: одна сессия содержит множество комментариев

**Почему JSON, а не отдельная таблица?**
- Упрощение для MVP
- Комментарии всегда загружаются вместе с сессией
- Нет необходимости в сложных JOIN'ах

**Недостатки:**
- Сложнее делать запросы по комментариям
- Нет индексации по полям комментариев

**Будущее улучшение:** При необходимости можно вынести комментарии в отдельную таблицу.

---

## 7. Docker Compose Services

### Описание
Эта диаграмма показывает структуру Docker контейнеров и их связи с volumes.

### Сервисы:

#### API (зелёный)
- **Порт:** 8000
- **Образ:** Собирается из `api/Dockerfile`
- **Зависимости:** Redis
- **Volumes:**
  - `./api/reviews.db` - база данных SQLite
  - `./artifacts` - генерируемые файлы
  - `./mr_packages` - пакеты MR
  - `./api/main.py` - hot reload для разработки
  - `./api/eval_worker.py` - hot reload для разработки

**Особенности:**
- Hot reload включён (`--reload` флаг)
- Монтирование исходников для быстрой разработки

#### Redis (красный)
- **Порт:** 6379
- **Образ:** `redis:7.2-alpine`
- **Назначение:** Очередь задач для RQ

**Конфигурация:**
- `appendonly yes` - персистентность через AOF
- `save ''` - отключение RDB snapshots
- `maxmemory-policy noeviction` - не удалять данные при нехватке памяти

#### Worker (жёлтый)
- **Образ:** Тот же, что и API (переиспользование)
- **Команда:** `rq worker default`
- **Зависимости:** Redis (должен быть healthy)
- **Volumes:** Те же, что и API (для доступа к БД и файлам)

**Особенности:**
- Использует тот же Dockerfile, что и API
- Разделение через разные команды запуска

#### Gitea (бирюзовый)
- **Порт:** 3000 (HTTP), 2222 (SSH)
- **Образ:** `gitea/gitea:1.22.2`
- **Зависимости:** API (для синхронизации запуска)
- **Volumes:**
  - `./gitea_data` - данные Gitea (репозитории, БД)
  - `./gitea_config` - конфигурация Gitea

**Конфигурация:**
- SQLite для БД (простота для MVP)
- Регистрация отключена (`DISABLE_REGISTRATION=true`)
- Пользователи создаются только через API

### Volumes (Хранилище данных)

**Локальные volumes (bind mounts):**
- `./api/reviews.db` - SQLite база данных
- `./artifacts` - генерируемые файлы (diff, отчёты)
- `./mr_packages` - пакеты MR с golden truth
- `./gitea_data` - данные Gitea
- `./gitea_config` - конфигурация Gitea

**Преимущества bind mounts:**
- Данные сохраняются на хосте
- Легко делать бэкапы
- Доступны для просмотра вне контейнера

**Недостатки:**
- Зависимость от файловой системы хоста
- Могут быть проблемы с правами доступа

---

## 8. Технологический стек

### Описание
Эта диаграмма показывает все используемые технологии и их зависимости.

### Frontend Stack

**React 19.1.1**
- UI библиотека
- Компонентный подход
- Хуки для управления состоянием

**Vite 7.1.7**
- Сборщик и dev-сервер
- Быстрая пересборка (HMR)
- Оптимизация для production

**React Router 6.31.1**
- Клиентская маршрутизация
- Разделение на `/reviewer` и `/candidate/:token`
- Программная навигация

**Monaco Editor**
- Редактор кода от VS Code
- Подсветка синтаксиса
- Отображение diff

**Зависимости:**
```
React → Vite → Router → Monaco
```

### Backend Stack

**FastAPI 0.119.1**
- Современный Python веб-фреймворк
- Автоматическая документация (Swagger)
- Валидация через Pydantic
- Асинхронная поддержка

**Python 3.11.10**
- Язык программирования
- Новые возможности (pattern matching, улучшенная производительность)

**Uvicorn 0.38.0**
- ASGI сервер
- Запускает FastAPI приложение
- Поддержка hot reload

**WeasyPrint 62.3**
- Генерация PDF из HTML
- Используется для создания отчётов
- Поддержка CSS для стилизации

**Зависимости:**
```
FastAPI → Python → Uvicorn
Python → WeasyPrint
```

### Data Stack

**SQLite**
- Встроенная БД
- Не требует отдельного сервера
- Файл: `reviews.db`
- Подходит для MVP и небольших нагрузок

**Redis 7.2**
- In-memory хранилище
- Используется как очередь задач
- Персистентность через AOF

### Task Queue

**RQ 2.6.0**
- Простая очередь задач для Python
- Использует Redis как бэкенд
- Легковесная альтернатива Celery

### Git Stack

**Gitea 1.22.2**
- Self-hosted Git сервер
- REST API для интеграции
- Управление пользователями и репозиториями
- Pull Requests и комментарии

**Зависимости:**
```
Python → RQ → Redis
Python → Gitea (через REST API)
```

---

## Общие архитектурные принципы

### 1. Разделение ответственности (Separation of Concerns)
- Frontend отвечает только за UI
- Backend обрабатывает бизнес-логику
- Worker выполняет тяжёлые вычисления
- Gitea управляет Git workflow

### 2. Асинхронность
- Длительные операции (оценка) вынесены в фоновый процесс
- API остаётся отзывчивым
- Redis Queue обеспечивает надёжность

### 3. Безопасность
- Токены для доступа кандидатов
- Разделение API endpoints по ролям
- Приватные репозитории в Gitea

### 4. Масштабируемость
- Worker можно масштабировать (несколько инстансов)
- Redis поддерживает кластеризацию
- SQLite можно заменить на PostgreSQL при необходимости

### 5. Отказоустойчивость
- Gitea опционален (fallback на старый workflow)
- Ошибки в Worker не влияют на API
- Персистентность данных через volumes

---

## Заключение

Эти диаграммы показывают:
1. **Структуру системы** - как компоненты связаны между собой
2. **Потоки данных** - как информация движется через систему
3. **Разделение ролей** - права доступа для каждой роли
4. **Структуру данных** - как хранятся данные
5. **Инфраструктуру** - Docker контейнеры и volumes
6. **Технологии** - используемый стек

Все диаграммы дополняют друг друга и дают полное представление об архитектуре системы.

